f na me(parameter) // "f na me" is a function name, space is valid character
{
local: 1
local 2: 3
If local 2 = parameter [ local ]
   local 3: local + parameter[ 0 ]
}
object: [ 5, 3] // short for { 0: 5, 1: 3 }
{ local 3: global } : f na me( object )

print( global ) // one argument allowed

...object.for({acc: 0, something: 4, something else: 5})({return, something}: ({value, key, acc}){return: key+value+acc, acc: value+ acc})
// key is index in this case,
// acc and any other than key and value is optional for object returns for with seted state
// ... asigns to this level
print( {return, something, something else} ) // {return: x, something: 5, something else: undefined}

{return: test while, i}:{}.while({i: 1})(({i}){return:i, if i = 3 exit: 1=1,i:i+1,i:i+1})

print({test while, i}) // {test while: 3, i: 5} asigment destinguish function call from function definition, we have imlicit   asigment